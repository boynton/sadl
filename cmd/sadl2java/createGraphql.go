package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/boynton/sadl"
	"github.com/boynton/sadl/extensions/graphql"
)

func (gen *PojoGenerator) createGraphqlHandler(data *serverData, gql *graphql.Model, packageDir string) {
	if gen.err != nil {
		return
	}
	className := graphqlClass(data.Model)
	funcMap := template.FuncMap{
		"openBrace": func() string { return "{" },
		"graphqlFetchers": func() string {
			return gen.graphqlFetchers(data.Model, gql)
		},
		"graphqlClass": func() string {
			return className
		},
	}
	gen.err = createFileFromTemplate(packageDir, className+".java", graphqlHandlerTemplate, data, funcMap)
}

func (gen *PojoGenerator) createGraphqlSchema(model *sadl.Model, gql *graphql.Model, dir string) {
	if gen.err != nil {
		return
	}
	schema := gen.graphqlSchema(model, gql)
	gen.err = os.MkdirAll(dir, 0755)
	if gen.err != nil {
		return
	}
	path := filepath.Join(dir, "schema.gql")
	f, err := os.Create(path)
	if err != nil {
		gen.err = err
	} else {
		defer f.Close()
		writer := bufio.NewWriter(f)
		_, err = writer.WriteString(schema)
		writer.Flush()
	}
}

func graphqlClass(model *sadl.Model) string {
	serviceName := capitalize(model.Name)
	return serviceName + "Graphql"
}

func (gen *PojoGenerator) graphqlTypeName(ts *sadl.TypeSpec) string {
	name := ts.Type
	switch ts.Type {
	case "Array":
		return "[" + ts.Items + "!]"
	case "String":
		return "String"
	case "Timestamp":
		return "String" //FIXME define a Timestamp Scalar. Same for UUID and other SADL primitive types
	default:
		td := gen.model.FindType(ts.Type)
		if td == nil {
			gen.err = fmt.Errorf("Cannot find type %q", ts.Type)
		}
		if td.Type != "Struct" {
			return td.Type
		}
	}
	return name
}

func (gen *PojoGenerator) graphqlSchema(model *sadl.Model, gql *graphql.Model) string {
	//full generation of schema from SADL. newlines are *not* ok for this
	var b bytes.Buffer
	writer := bufio.NewWriter(&b)
	writer.WriteString("#\n# Generated by sadl2java\n#\n")
	for _, ty := range model.Types {
		switch ty.Type {
		case "Struct":
			if ty.Comment != "" {
				writer.WriteString("\n\"\"\"\n" + ty.Comment + "\n\"\"\"")
			}
			writer.WriteString("\ntype " + ty.Name + " {\n")
			for _, f := range ty.Fields {
				gqlType := gen.graphqlTypeName(&f.TypeSpec)
				if f.Required {
					gqlType = gqlType + "!"
				}
				if f.Comment != "" {
					writer.WriteString(fmt.Sprintf("    %q\n", f.Comment))
				}
				writer.WriteString("    " + f.Name + ": " + gqlType + ",\n")
			}
			writer.WriteString("}\n")
		case "String":
			//nothing
		default:
			writer.WriteString("//? " + ty.Name + ": " + ty.Type + "\n")
		}
	}
	writer.WriteString("\ntype Query {")
	for i, op := range gql.Operations {
		opType := gen.graphqlTypeName(op.Return)
		if i > 0 {
			writer.WriteString(",")
		}
		writer.WriteString("\n    ")
		writer.WriteString(op.Name)
		if len(op.Params) > 0 {
			writer.WriteString("(")
			for j, param := range op.Params {
				if j > 0 {
					writer.WriteString(", ")
				}
				writer.WriteString(param.Name)
				writer.WriteString(": ")
				writer.WriteString(param.Type)
				writer.WriteString("!")
			}
			writer.WriteString(")")
		}
		writer.WriteString(": " + opType)
	}
	writer.WriteString("\n}\n")
	writer.Flush()
	s := b.String()
	return s
}

func (gen *PojoGenerator) graphqlFetchers(model *sadl.Model, gql *graphql.Model) string {
	indent := "            "
	result := ""
	for _, op := range gql.Operations {
		rType, _, _ := gen.typeName(op.Return, op.Return.Type, true)
		indent2 := indent + "            "
		q := indent + `.type("Query", builder -> builder.dataFetcher("` + op.Name + `", new DataFetcher<` + rType + ">() {\n"
		q = q + indent2 + "public " + rType + " get(DataFetchingEnvironment env) throws Exception {\n"
		if len(op.Params) > 0 {
			for _, param := range op.Params {
				q = q + indent2 + "    " + param.Type + " " + param.Name + ` = env.getArgument("` + param.Name + "\");\n"
			}
		}
		q = q + indent2 + "    " + op.Provider + "Response res = impl." + uncapitalize(op.Provider) + "(new " + op.Provider + "Request()"
		if len(op.Params) > 0 {
			for _, param := range op.Params {
				q = q + "." + param.Name + "(" + param.Name + ")"
			}
		}
		q = q + ");\n"
		q = q + indent2 + "    return res." + op.Name + ";\n"
		q = q + indent2 + "}\n"
		result = result + q + indent + "        }))\n"
	}
	return result
}

const graphqlHandlerTemplate = `//
// Created by sadl2java
//
{{.PackageLine}}

import java.util.Map;
import java.util.List;
import java.util.ArrayList;

import graphql.ExecutionInput;
import graphql.ExecutionResult;
import graphql.GraphQL;
import graphql.GraphQLError;
import graphql.schema.GraphQLSchema;
import graphql.schema.DataFetcher;
import graphql.schema.DataFetchingEnvironment;
import graphql.schema.idl.RuntimeWiring;
import graphql.schema.idl.SchemaGenerator;
import graphql.schema.idl.SchemaParser;
import graphql.schema.idl.TypeDefinitionRegistry;

import static graphql.schema.idl.RuntimeWiring.newRuntimeWiring;

public class {{graphqlClass}} {

    static String getSchema(String name) {
        try {
            ClassLoader classLoader = new {{graphqlClass}}().getClass().getClassLoader();
            java.net.URL url = classLoader.getResource(name);
            if (url != null) {
                java.io.File file = new java.io.File(url.getFile());
                return new String(java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(file.getPath())), java.nio.charset.StandardCharsets.UTF_8);
            } else {
                throw new Exception("Cannot find resource: " + name);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "";
    }

    public static GraphqlResponse execute(GraphqlRequest req, {{.InterfaceClass}} impl) {
        String query = req.query;
        Map<String,Object> variables = req.variables;

        String schema = getSchema("schema.gql");
        
        SchemaParser schemaParser = new SchemaParser();
        TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema);
        
        RuntimeWiring runtimeWiring = newRuntimeWiring()
{{graphqlFetchers}}            .build();
        
        SchemaGenerator schemaGenerator = new SchemaGenerator();
        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);
        
        GraphQL build = GraphQL.newGraphQL(graphQLSchema).build();
        
        ExecutionInput.Builder input = new ExecutionInput.Builder().query(query);
        if (variables != null) {
            input.variables(variables);
        }
        ExecutionResult executionResult = build.execute(input);

        ArrayList<Object> lstErrors = new ArrayList<Object>();
        for (GraphQLError err : executionResult.getErrors()) {
            lstErrors.add(err.toSpecification());
        }
        GraphqlResponse res = new GraphqlResponse().data(executionResult.getData()).errors(lstErrors);
        System.out.println("=>\n" + Json.pretty(res));
        return res;
    }

    //Resolvers could be implemented as inner classes here

}
`

func (gen *PojoGenerator) createGraphqlRequestPojo() {
	if gen.err != nil {
		return
	}
	ts := &sadl.TypeSpec{
		Type: "Struct",
		Fields: []*sadl.StructFieldDef{
			&sadl.StructFieldDef{
				Name:     "query",
				Required: true,
				TypeSpec: sadl.TypeSpec{
					Type: "String",
				},
			},
			&sadl.StructFieldDef{
				Name: "operationName",
				TypeSpec: sadl.TypeSpec{
					Type: "String",
				},
			},
			&sadl.StructFieldDef{
				Name: "variables",
				TypeSpec: sadl.TypeSpec{
					Type:  "Map",
					Keys:  "String",
					Items: "Any",
				},
			},
		},
	}
	className := "GraphqlRequest"
	var b bytes.Buffer
	gen.writer = bufio.NewWriter(&b)
	gen.createStructPojo(ts, className, "")
	gen.writer.Flush()
	gen.finishPojo(b, className)
}

func (gen *PojoGenerator) createGraphqlResponsePojo() {
	if gen.err != nil {
		return
	}
	ts := &sadl.TypeSpec{
		Type: "Struct",
		Fields: []*sadl.StructFieldDef{
			&sadl.StructFieldDef{
				Name: "data",
				TypeSpec: sadl.TypeSpec{
					Type:  "Map",
					Keys:  "String",
					Items: "Any",
				},
			},
			&sadl.StructFieldDef{
				Name: "errors",
				TypeSpec: sadl.TypeSpec{
					Type:  "Array",
					Items: "Any",
				},
			},
		},
	}
	className := "GraphqlResponse"
	var b bytes.Buffer
	gen.writer = bufio.NewWriter(&b)
	gen.createStructPojo(ts, className, "")
	gen.writer.Flush()
	gen.finishPojo(b, className)
}
