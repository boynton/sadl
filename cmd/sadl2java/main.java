package main

import(
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/boynton/sadl"
	"github.com/boynton/sadl/parse"
)

func main() {
	pLombok := flag.Bool("l", false, "generate Lombok annotations")
	pGetters := flag.Bool("g", false, "generate setters/getters instead of the default fluent style")
	pOutdir := flag.String("o", "", "output directory for generated source")
	pPackage := flag.String("p", "", "Java package for generated source")
	pJsonutil := flag.Bool("j", false, "Create Json.java utility class")
	flag.Parse()
	argv := flag.Args()
	argc := len(argv)
	if argc == 0 {
		fmt.Fprintf(os.Stderr, "usage: sadl2pojo -o=outdir -p=java.package.name -g -l some_model.sadl\n")
		os.Exit(1)
	}
	model, err := parse.File(argv[0])
	if err != nil {
		fmt.Fprintf(os.Stderr, "*** %v\n", err)
		os.Exit(1)
	}
//	fmt.Println(parse.Pretty(model))
	err = generatePojos(model, *pOutdir, *pPackage, *pLombok, *pGetters, *pJsonutil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "*** %v\n", err)
		os.Exit(1)
	}
}

func generatePojos(model *sadl.Model, outdir, pkg string, lombok, getters, jsonutil bool) error {
	gen := newPojoGenerator(model, outdir, pkg, lombok, getters, jsonutil)
	if gen.jsonutil {
		gen.createJsonUtil()
	}
	for _, td := range model.Types {
		gen.createPojo(td)
	}
	return gen.err
}

func newPojoGenerator(model *sadl.Model, outdir, pkg string, lombok, getters, jsonutil bool) *PojoGenerator {
   gen := &PojoGenerator{
		model: model,
		outdir: outdir,
		pkgname: pkg,
		lombok: lombok,
		getters: getters,
		jsonutil: jsonutil,
		header: "//\n// Generated by sadl2java\n//\n",
   }
	gen.pkgpath = filepath.Join(gen.outdir, javaPackageToPath(gen.pkgname))
	if gen.pkgpath != "" {
		err := os.MkdirAll(gen.pkgpath, 0755)
		if err != nil {
			gen.err = err
		}
	}
	return gen
}

type PojoGenerator struct {
	model *sadl.Model
	outdir string
	pkgname string
	pkgpath string
	imports []string
	lombok bool
	getters bool
	jsonutil bool
	header string
	file *os.File
   writer     *bufio.Writer
	err        error
}

func (gen *PojoGenerator) createJavaFile(name string) {
	if gen.err != nil {
		return
	}
	path := filepath.Join(gen.pkgpath, name + ".java")
   f, err := os.Create(path)
   if err != nil {
		gen.err = err
		return
   }
	gen.file = f
   gen.writer = bufio.NewWriter(f)
	gen.emit(gen.header)
	if gen.pkgname != "" {
		gen.emit("package " + gen.pkgname + ";\n\n")
	}
}
n
func (gen *PojoGenerator) createPojo(td *sadl.TypeDef) {
	if gen.err != nil {
		return
	}
   var b bytes.Buffer
	gen.writer = bufio.NewWriter(&b) //first write to a string
	className := capitalize(td.Name)
	switch td.Type {
	case "Struct":
		gen.createStructPojo(td, className)
	case "Quantity":
		gen.createQuantityPojo(td, className)
	case "Enum":
		gen.createEnumPojo(td, className)
	default:
		//do nothing, i.e. a String subclass
	}
	if gen.err == nil {
		gen.writer.Flush()
		gen.createJavaFile(td.Name) //then create file and write the header with imports
		for _, pack := range gen.imports {
			gen.emit("import " + pack + ";\n")
		}
		b.WriteTo(gen.writer) //and append the originally written output after that
		gen.writer.Flush()
		gen.file.Close()
	}
}

func (gen *PojoGenerator) createQuantityPojo(td *sadl.TypeDef, className string) {
	gen.addImport("javax.validation.constraints.NotNull")
	gen.addImport("com.fasterxml.jackson.annotation.JsonValue")
	gen.emit("public class " + className + "{\n\n")

	valueType, _ := gen.typeName(&td.TypeSpec, td.Value, true)
	unitType := td.Unit
	gen.emit("    public " + valueType + " value;\n")
	gen.emit("    public " + unitType + " unit;\n\n")

	gen.emit("    public " + className + "(" + valueType + " value, " + unitType + " unit) {\n")
	gen.emit("        this.value = value;\n")
	gen.emit("        this.unit = unit;\n")
	gen.emit("    }\n")
	
	v := "<bad value type, must be numeric>"
	switch valueType {
	case "double":
		v = "Double.parseDouble(tmp[0])"
	case "float":
		v = "Float.parseFloat(tmp[0])"
	case "long":
		v = "Long.parseLong(tmp[0])"
	case "int":
		v = "Integer.parseInt(tmp[0])"
	case "short":
		v = "Short.parseShort(tmp[0])"
	case "byte":
		v = "Byte.parseByte(tmp[0])"
	case "BigDecimal":
		v = "new BigDecimal(tmp[0])"
	default:
		fmt.Println("Whoops:", valueType)
		panic("here")
	}
	u := "<bad unit type, must be enum or string>"
	ut := gen.model.FindType(unitType)
	switch ut.Type {
	case "String":
		u = "tmp[1]"
	case "Enum":
		u = unitType + ".fromString(tmp[1])"
	}
	gen.emit("    public " + className + "(@NotNull String repr) {\n")
	gen.emit("        String[] tmp = repr.split(\" \");\n")
	gen.emit("        this.value = " + v + ";\n")
	gen.emit("        this.unit = " + u + ";\n")
	gen.emit("    }\n\n")

	gen.emit("    public " + className + " value(" + valueType + " value) {\n")
	gen.emit("        this.value = value;\n")
	gen.emit("        return this;\n")
	gen.emit("    }\n\n")

	gen.emit("    public " + className + " unit(" + unitType + " unit) {\n")
	gen.emit("        this.unit = unit;\n")
	gen.emit("        return this;\n")
	gen.emit("    }\n\n")

	gen.emit(`    @JsonValue
    @Override
    public String toString() {
        return value + " " + unit;
    }
}
`)
}

func (gen *PojoGenerator) createEnumPojo(td *sadl.TypeDef, className string) {
	gen.addImport("com.fasterxml.jackson.annotation.JsonValue")

	gen.emit("public enum " + className + "{\n")
	max := len(td.Elements)
	delim := ",\n"
	for i:=0; i<max; i++ {
		el := td.Elements[i]
		if i == max-1 {
			delim = ";\n\n"
		}
		gen.emit("    " + strings.ToUpper(el.Symbol) + "(\"" + el.Symbol + "\")" + delim)
	}
	gen.emit("    private String repr;\n\n")
	gen.emit("    private " + className + "(String repr) {\n        this.repr = repr;\n    }\n\n")

	gen.emit("    @JsonValue\n    @Override\n")
	gen.emit("    public String toString() {\n        return repr;\n    }\n\n")

	gen.emit("    public static " + className + " fromString(String repr) {\n")
	gen.emit("        for (" + className + " e : values()) {\n")
	gen.emit("            if (e.repr.equals(repr)) {\n")
	gen.emit("                return e;\n")
	gen.emit("            }\n")
	gen.emit("        }\n")
	gen.emit("        throw new IllegalArgumentException(\"Invalid string representation for " + className + ": \" + repr);\n")
	gen.emit("    }\n\n")
	gen.emit("}\n")
}

func (gen *PojoGenerator) createStructPojo(td *sadl.TypeDef, className string) {
	optional := false
   for _, fd := range td.Fields {
		if !fd.Required {
			optional = true
		}
	}
	
	if optional {
		gen.addImport("java.util.List")
		gen.addImport("javax.validation.constraints.NotNull")
		gen.addImport("com.fasterxml.jackson.annotation.JsonInclude")
//		gen.emit("@JsonInclude(JsonInclude.Include.NON_EMPTY)\n")
	} else {
		gen.emit("\n")
	}
	gen.emit("public class " + className + "{\n")
	for _, fd := range td.Fields {
		if !fd.Required {
			gen.emit("    @JsonInclude(JsonInclude.Include.NON_EMPTY) /* Optional field */\n")
		}
		tn, tp := gen.typeName(&fd.TypeSpec, fd.Type, fd.Required)
		if tp != "" {
			tp = tp + " "
		}
		gen.emit("    public " + tp + tn + " " + fd.Name + ";\n\n")
	}
	for _, fd := range td.Fields {
		gen.emitFluidSetter(td, fd)
	}
	if gen.jsonutil {
		gen.emit(`    @Override
    public String toString() {
        return Json.pretty(this);
    }
`)
	}
	gen.emit("}\n")
}

func (gen *PojoGenerator) emitFluidSetter(td *sadl.TypeDef, fd *sadl.StructFieldDef) {
	if gen.err != nil {
		return
	}
	tn, tp := gen.typeName(&fd.TypeSpec, fd.Type, fd.Required)
	if tp != "" {
		tp = tp + " "
	}
	gen.emit("    public " + td.Name + " " + fd.Name + "(" + tp + tn + " val) {\n")
	gen.emit("        this." + fd.Name + " = val;\n")
	gen.emit("        return this;\n")
	gen.emit("    }\n\n")
}

func adjoin(lst []string, val string) []string {
	for _, s := range lst {
		if val == s {
			return lst
		}
	}
	return append(lst, val)
}

func (gen *PojoGenerator) addImport(fullReference string) {
	gen.imports = adjoin(gen.imports, fullReference)
}

func (gen *PojoGenerator) requiredPrimitiveTypeName(nameOptional, nameRequired string, required bool) string {
	if !required {
		return nameOptional
	}
	return nameRequired
}

func (gen *PojoGenerator) typeName(ts *sadl.TypeSpec, name string, required bool) (string, string) {
	switch name {
	case "Int8":
		return gen.requiredPrimitiveTypeName("Byte", "byte", required), ""
	case "Int16":
		return gen.requiredPrimitiveTypeName("Short", "short", required), ""
	case "Int32":
		return gen.requiredPrimitiveTypeName("Integer", "int", required), ""
	case "Int64":
		return gen.requiredPrimitiveTypeName("Long", "long", required), ""
	case "Float32":
		return gen.requiredPrimitiveTypeName("Float", "float", required), ""
	case "Float64":
		return gen.requiredPrimitiveTypeName("Double", "double", required), ""
	case "Decimal":
		gen.addImport("java.math.BigDecimal")
		if required {
			gen.addImport("javax.validation.constraints.NotNull")
			return "BigDecimal", "@NotNull"
		}
		return "BigDecimal", ""
	case "Bool":
		return gen.requiredPrimitiveTypeName("Boolean", "boolean", required), ""
	case "String":
		if required {
			gen.addImport("javax.validation.constraints.NotNull")
			return name, "@NotNull"
		}
		return name, ""
	case "Array":
		items := ts.Items
		if required {
			gen.addImport("javax.validation.constraints.NotNull")
			return "List<" + items + ">", "@NotNull"
		}
		return "List<" + items + ">", ""
	default:
		//must be a app-defined class. Parser should have already verified its existence
		td := gen.model.FindType(name)
		if td == nil {
			panic("Unresolved type, parser should have caught this: " + name)
		}
		return name, ""
	}
}

func (gen *PojoGenerator) emit(s string) {
	if gen.err == nil {
		_, err := gen.writer.WriteString(s)
		if err != nil {
			gen.err = err
		}
	}
}

func javaPackageToPath(pkg string) string {
	return strings.Join(strings.Split(pkg, "."), "/")
}

func capitalize(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}

func uncapitalize(s string) string {
	return strings.ToLower(s[0:1]) + s[1:]
}

func (gen *PojoGenerator) createJsonUtil() {
	gen.createJavaFile("Json")
	if gen.err != nil {
		return
	}
	gen.emit(javaJsonUtil)
	gen.writer.Flush()
	gen.file.Close()
}

var javaJsonUtil = `
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.DeserializationFeature;

public class Json {

    static final ObjectMapper om = initMapper();
    static ObjectMapper initMapper() {
        ObjectMapper om = new ObjectMapper();
        om.disable(SerializationFeature.WRITE_NULL_MAP_VALUES);
        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return om;
    }

    public static <T> T parse(String jsonData, Class<T> dataType) {
        try {
            return om.readerFor(dataType).readValue(jsonData);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String string(Object o) {
        try {
            Class<?> cls = (o == null)? Object.class : o.getClass();
            return om.writerWithView(cls).writeValueAsString(o);
        } catch (Exception e) {
            e.printStackTrace();
            return "?";
        }
    }

    public static String pretty(Object o) {
        try {
            Class<?> cls = (o == null)? Object.class : o.getClass();
            return om.writerWithView(cls).with(SerializationFeature.INDENT_OUTPUT).writeValueAsString(o);
        } catch (Exception e) {
            e.printStackTrace();
            return "?";
        }
    }

    public static <T> String[] validate(T t) {
        return new String[0]; //replace with a real validator
    }
}
`

