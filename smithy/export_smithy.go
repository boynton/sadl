package smithy

import (
	"fmt"
	"strings"

	"github.com/boynton/sadl"
)

func FromSADL(schema *sadl.Model, ns string) (*Model, error) {
	model := &Model{
		Version: "0.5.0",
		Shapes: make(map[string]*Shape, 0),
	}
	for _, td := range schema.Types {
		err := defineShapeFromTypeSpec(schema, ns, model.Shapes, &td.TypeSpec, td.Name, td.Comment, td.Annotations)
		if err != nil {
			return nil, err
		}
	}
	for _, hd := range schema.Http {
		expectedCode := 200
		if hd.Expected != nil {
			expectedCode = int(hd.Expected.Status)
		}
		path := hd.Path
		n := strings.Index(path, "?")
		if n >= 0 {
			path = path[:n]
		}
		name := capitalize(hd.Name)
		if name == "" {
			name = capitalize(strings.ToLower(hd.Method)) + "Something" //fix!
			fmt.Println("FIX:", name)
		}
		shape := Shape{
			Type: "operation",
		}
		ensureShapeTraits(&shape).Http = &Http{
			Uri: path,
			Method: hd.Method,
			Code: expectedCode,
		}
		switch hd.Method {
		case "GET":
			ensureShapeTraits(&shape).ReadOnly = true
		case  "PUT", "DELETE":
			ensureShapeTraits(&shape).Idempotent = true
		}

		//if we have any inputs, define this
		if len(hd.Inputs) > 0 {
			shape.Input = &Member{Target: ns+"#"+name + "Input"}
			inShape := Shape{
				Type: "structure",
				Members: make(map[string]*Member, 0),
			}
			//		inShape.Documentation = "[autogenerated for operation '" + name + "']"
			for _, in := range hd.Inputs {
				mem := &Member{
					Target: in.Type,
				}
				if in.Path {
					ensureMemberTraits(mem).HttpLabel = true
					ensureMemberTraits(mem).Required = true
				} else if in.Query != "" {
					ensureMemberTraits(mem).HttpQuery = in.Query
				} else if in.Header != "" {
					ensureMemberTraits(mem).HttpHeader = in.Header
				} else {
					ensureMemberTraits(mem).HttpPayload = true
				}
				inShape.Members[in.Name] = mem
			}
			model.Shapes[shape.Input.Target] = &inShape
		}

		if len(hd.Expected.Outputs) > 0 {
			//if we have any outputs, define this
			shape.Output = &Member{Target: ns+"#"+name + "Output"}
			outShape := Shape{
				Type: "structure",
				Members: make(map[string]*Member, 0),
			}
			//		outShape.Documentation = "[autogenerated for operation '" + name + "']"
			for _, out := range hd.Expected.Outputs {
				mem := &Member{
					Target: out.Type,
				}
				if out.Header != "" {
					ensureMemberTraits(mem).HttpHeader = out.Header
				} else {
					ensureMemberTraits(mem).HttpPayload = true
				}
				outShape.Members[out.Name] = mem
			}
			model.Shapes[shape.Output.Target] = &outShape
		}


		//if we have any exceptions, define them
		if len(hd.Exceptions) > 0 {
			for _, e := range hd.Exceptions {
				em := &Member{Target: ns+"#"+e.Type}
				shape.Errors = append(shape.Errors, em)
				if tmp, ok := model.Shapes[em.Target]; ok {
					ensureShapeTraits(tmp).HttpError = e.Status
				} else {
					return nil, fmt.Errorf("Cannot find shape for error declaration type %q", e.Type)
				}
			}
		}
		model.Shapes[ns+"#"+name] = &shape
/*
//from the smithy docs:
@http(method: "PUT", uri: "/{bucketName}/{key}", code: 200)
operation PutObject(PutObjectInput)
structure PutObjectInput {
    // Sent in the URI label named "key".
    @required
    @httpLabel
    key: ObjectKey,

    // Sent in the URI label named "bucketName".
    @required
    @httpLabel
    bucketName: String,

    // Sent in the X-Foo header
    @httpHeader("X-Foo")
    foo: String,

    // Sent in the query string as paramName
    @httpQuery("paramName")
    someValue: String,

    // Sent in the body
    data: MyBlob,

    // Sent in the body
    additional: String,
}

*/		
	}
	return model, nil
}

func typeReference(ts *sadl.TypeSpec) string {
	switch ts.Type {
	case "Bool":
		return "Boolean"
	case "Int8":
		return "Byte"
	case "Int16":
		return "Short"
	case "Int32":
		return "Integer"
	case "Int64":
		return "Long"
	case "Float32":
		return "Float"
	case "Float64":
		return "Double"
	case "Decimal":
		return "BigDecimal"
	case "Timestamp":
		return "Timestamp"
	case "UUID":
		return "String" //!
	case "Bytes":
		return "Blob"
	case "String":
		return "String"
	case "Array":
		return "List"
	case "Map":
		return "Map"
//	case "Struct": /naked struct
//		return "?"
	default:
		return ts.Type
	}
}

func listTypeReference(schema *sadl.Model, ns string, shapes map[string]*Shape, prefix string, fd *sadl.StructFieldDef) string {
	ftype := capitalize(prefix) + capitalize(fd.Name)
	td := schema.FindType(ftype)
	if td != nil {
		fmt.Printf("Inline defs not allowed, synthesize %q to refer to: %s\n", ftype, sadl.Pretty(fd))
		panic("Already have one with that name!!!")
	}
	shape := Shape{
		Type: "list",
	}
	shape.Member = &Member{
		Target: fd.Items,
	}
	ensureShapeTraits(&shape).Documentation = "[autogenerated for field '" + fd.Name + "' in struct '" + prefix + "']";
	shapes[ns+"#"+ftype] = &shape
	return ftype
}

func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[0:1]) + s[1:]
}

func ensureShapeTraits(shape *Shape) *Traits {
	if shape.Traits == nil {
		shape.Traits = &Traits{}
	}
	return shape.Traits
}

func ensureMemberTraits(member *Member) *Traits {
	if member.Traits == nil {
		member.Traits = &Traits{}
	}
	return member.Traits
}

func defineShapeFromTypeSpec(model *sadl.Model, ns string, shapes map[string]*Shape, ts *sadl.TypeSpec, name string, comment string, annos map[string]string) error {
	var shape Shape
	switch ts.Type {
	case "String":
		shape = shapeFromString(ts)
	case "Enum":
		shape = shapeFromEnum(ts)
	case "Struct":
		//schema *sadl.Model, ns *Namespace, tname string, ts *sadl.TypeSpec
		shape = shapeFromStruct(model, ns, shapes, name, ts)
	default:
		fmt.Println("So far:", sadl.Pretty(model))
		panic("handle this type:" + sadl.Pretty(ts))
	}
	if comment != "" {
		ensureShapeTraits(&shape).Documentation = comment
	}
	if annos != nil {
		for k, v := range annos {
			switch k {
			case "x_sensitive":
				ensureShapeTraits(&shape).Sensitive = true
			case "x_deprecated":
				dep := &Deprecated{}
				if v != "" {
					n := strings.Index(v, "|")
					if n >= 0 {
						dep.Since = v[:n]
						dep.Message = v[n+1:]
					} else {
						dep.Message = v
					}
				}
				ensureShapeTraits(&shape).Deprecated = dep
			}
		}
	}
	shapes[ns+"#"+name] = &shape
	return nil
}

func shapeFromStruct(schema *sadl.Model, ns string, shapes map[string]*Shape, tname string, ts *sadl.TypeSpec) Shape {
	shape := Shape{
		Type: "structure",
	}
	members := make(map[string]*Member, 0)
	for _, fd := range ts.Fields {
		ftype := typeReference(&fd.TypeSpec)
		switch ftype {
		case "List":
			ftype = listTypeReference(schema, ns, shapes, tname, fd)
		}
		member := &Member{
			Target: ftype,
		}
		if fd.Required {
			member.Traits = &Traits{Required: true}
		}
		members[fd.Name] = member
	}
	shape.Members = members
	return shape
}

func shapeFromString(ts *sadl.TypeSpec) Shape {
	shape := Shape{
		Type: "string",
	}
	min := int64(-1)
	max := int64(-1)
	if ts.MinSize != nil {
		min = *ts.MinSize
	}
	if ts.MaxSize != nil {
		max = *ts.MaxSize
	}
	l := length(min, max)
	if l != nil {
		ensureShapeTraits(&shape).Length = l
	}
	if ts.Pattern != "" {
		ensureShapeTraits(&shape).Pattern = ts.Pattern
	}
	if len(ts.Values) > 0 {
		e := make(map[string]*Item, 0)
		for _, s := range ts.Values {
			ei := &Item{
				Name: s,
			}
			e[s] = ei
		}
		ensureShapeTraits(&shape).Enum = e
	}
	return shape
}

func shapeFromEnum(ts *sadl.TypeSpec) Shape {
	shape := Shape{
		Type: "string",
	}
	//for sadl, enum values *are* the symbols, so the name must be set to match the key
	//note that this same form can work with values, where the name is optional but the key is the actual value
	items := make(map[string]*Item, 0)
	ensureShapeTraits(&shape).Enum = items
	for _, el := range ts.Elements {
		item := &Item{
			Name: el.Symbol, //the programmatic name, might be different than the value itself in Smithy. In SADL, they are the same.
			Documentation: el.Comment,
		}
		items[el.Symbol] = item
		//el.Annotations -> if contains x_tags, then expand to item.Tags
	}
	return shape
}

func length(min int64, max int64) *Length {
	l := &Length{}
	if min < 0 && max < 0 {
		return nil
	}
	if min >= 0 {
		l.Min = &min
	}
	if max >= 0 {
		l.Max = &max
	}
	return l
}
