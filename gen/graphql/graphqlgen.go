package graphql

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/boynton/sadl"
	"github.com/boynton/sadl/gen"
)

type Generator struct {
	gen.Generator
}

func (gen *Generator) CreateGraphqlSchema(dir string) {
	if gen.Err != nil || gen.Graphql == nil {
		return
	}
	schema := gen.graphqlSchema()
	gen.Err = os.MkdirAll(dir, 0755)
	if gen.Err != nil {
		return
	}
	path := filepath.Join(dir, "schema.gql")
	f, err := os.Create(path)
	if err != nil {
		gen.Err = err
	} else {
		defer f.Close()
		writer := bufio.NewWriter(f)
		_, err = writer.WriteString(schema)
		writer.Flush()
	}
}

func (gen *Generator) graphqlClass(model *sadl.Model) string {
	serviceName := gen.Capitalize(model.Name)
	return serviceName + "Graphql"
}

func (gen *Generator) graphqlTypeName(ts *sadl.TypeSpec) string {
	name := ts.Type
	switch ts.Type {
	case "Array":
		return "[" + ts.Items + "!]"
	case "String":
		return "String"
	case "Timestamp":
		return "String" //FIXME define a Timestamp Scalar. Same for UUID and other SADL primitive types
	default:
		td := gen.Model.FindType(ts.Type)
		if td == nil {
			gen.Err = fmt.Errorf("Cannot find type %q", ts.Type)
		}
		if td.Type != "Struct" {
			return td.Type
		}
	}
	return name
}

func (gen *Generator) graphqlSchema() string {
	model := gen.Model
	gql := gen.Graphql
	//full generation of schema from SADL. newlines are *not* ok for this
	var b bytes.Buffer
	writer := bufio.NewWriter(&b)
	writer.WriteString("#\n# Generated by sadl2java\n#\n")
	for _, ty := range model.Types {
		switch ty.Type {
		case "Struct":
			if ty.Comment != "" {
				writer.WriteString("\n\"\"\"\n" + ty.Comment + "\n\"\"\"")
			}
			writer.WriteString("\ntype " + ty.Name + " {\n")
			for _, f := range ty.Fields {
				gqlType := gen.graphqlTypeName(&f.TypeSpec)
				if f.Required {
					gqlType = gqlType + "!"
				}
				if f.Comment != "" {
					writer.WriteString(fmt.Sprintf("    %q\n", f.Comment))
				}
				writer.WriteString("    " + f.Name + ": " + gqlType + ",\n")
			}
			writer.WriteString("}\n")
		case "String":
			//nothing
		default:
			writer.WriteString("//? " + ty.Name + ": " + ty.Type + "\n")
		}
	}
	writer.WriteString("\ntype Query {")
	for i, op := range gql.Operations {
		opType := gen.graphqlTypeName(op.Return)
		if i > 0 {
			writer.WriteString(",")
		}
		writer.WriteString("\n    ")
		writer.WriteString(op.Name)
		if len(op.Params) > 0 {
			writer.WriteString("(")
			for j, param := range op.Params {
				if j > 0 {
					writer.WriteString(", ")
				}
				writer.WriteString(param.Name)
				writer.WriteString(": ")
				writer.WriteString(param.Type)
				writer.WriteString("!")
			}
			writer.WriteString(")")
		}
		writer.WriteString(": " + opType)
	}
	writer.WriteString("\n}\n")
	writer.Flush()
	s := b.String()
	return s
}

