package golang

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/boynton/sadl"
)

func Export(model *sadl.Model, dir string, conf *sadl.Data) error {
	gen := NewGenerator(model, dir, conf)
	if gen.createModel {
		gen.CreateModel()
	}
	if gen.createServer {
		//main.go ?
		gen.CreateServer()
	}
	if gen.createClient {
		//client_test.go ?
		gen.CreateClient()
	}
	return gen.Err
}

type Generator struct {
	sadl.Generator
	Model           *sadl.Model
	Header          string
	Name            string
	Pkg             string
	createModel     bool
	createServer    bool
	createClient    bool
	createTimestamp bool //set if Timestamps are encountered in the model
	createDecimal   bool //set if Decimals are encountered in the model
	runtime         bool
	pkgpath         string
	imports         []string
	buf             *bytes.Buffer
	file            *os.File
	writer          *bufio.Writer
}

func NewGenerator(model *sadl.Model, outdir string, config *sadl.Data) *Generator {
	gen := &Generator{}
	gen.Config = config
	gen.OutDir = outdir
	gen.Model = model
	gen.Header = "//\n// Generated by sadl\n//\n"
	gen.createModel = gen.GetConfigBool("model", true)
	gen.createServer = gen.GetConfigBool("server", false)
	gen.createClient = gen.GetConfigBool("client", false)
	gen.Name = sadl.Capitalize(gen.GetConfigString("name", model.Name))
	pkg := gen.GetConfigString("package", "")
	if pkg == "" {
		pkg = model.Namespace
		if pkg == "" {
			pkg = "main"
		}
	}
	gen.Pkg = pkg
	pkgpath := pkg
	if strings.Index(gen.Pkg, ".") >= 0 {
		lstpath := strings.Split(pkg, ".")
		gen.Pkg = lstpath[len(lstpath)-1]
		pkgpath = strings.Join(lstpath, "/")
	}
	gen.pkgpath = filepath.Join(gen.OutDir, pkgpath)
	if gen.pkgpath != "" {
		err := os.MkdirAll(gen.pkgpath, 0755)
		if err != nil {
			gen.Err = err
		}
	}
	gen.runtime = gen.GetConfigBool("runtime", false)
	return gen
}

func (gen *Generator) WriteGoFile(name string, content string, pkg string) {
	if gen.Err == nil {
		head := gen.Header + "package " + pkg + "\n"
		if len(gen.imports) > 0 {
			head = head + "\nimport(\n"
			for _, pack := range gen.imports {
				head = head + "\t\"" + pack + "\"\n"
			}
			head = head + ")\n"
		}
		content = head + content
		path := filepath.Join(gen.pkgpath, name)
		gen.WriteFile(path, content)
	}
}

func (gen *Generator) NeedsDecimalType() bool {
	if !gen.runtime {
		for _, pack := range gen.imports {
			if pack == "math/big" {
				return true
			}
		}
	}
	return false
}

func adjoin(lst []string, val string) []string {
	for _, s := range lst {
		if val == s {
			return lst
		}
	}
	return append(lst, val)
}

func (gen *Generator) addImport(fullReference string) {
	gen.imports = adjoin(gen.imports, fullReference)
}

func (gen *Generator) EmitJsonUtil() {
	if gen.Err != nil {
		return
	}
	gen.addImport("encoding/json")
	gen.addImport("fmt")
	gen.Emit(goJsonUtil)
}

var goJsonUtil = `
func Pretty(obj interface{}) string {
	j, err := json.MarshalIndent(obj, "", "    ")
	if err != nil {
		return fmt.Sprint(obj)
	}
	return string(j)
}
`

/*
func (gen *Generator) createGoFile(name string) {
	if gen.Err != nil {
		return
	}
	path := filepath.Join(gen.pkgpath, name+".go")
	f, err := os.Create(path)
	if err != nil {
		gen.Err = err
		return
	}
	gen.file = f
	gen.writer = bufio.NewWriter(f)
	gen.Emit(gen.Header)
	gen.Emit("package " + gen.pkg + ";\n\n")
}
*/

func (gen *Generator) requiredPrimitiveTypeName(nameOptional, nameRequired string, required bool) string {
	if !required {
		return nameOptional
	}
	return nameRequired
}

func (gen *Generator) nativeTypeName(ts *sadl.TypeSpec, name string) string {
	//not happy about optional values in Go. For now, just let zero values be omitted for optional fields.
	switch name {
	case "Int8", "Int16", "Int32", "Int64", "Float32", "Float64", "Bool", "String":
		return uncapitalize(name)
	case "Decimal":
		if gen.runtime {
			gen.addImport("github.com/boynton/sadl")
			return "*sadl." + name
		} else {
			gen.createDecimal = true
			//			gen.addImport("math/big")
			return "*" + name
		}
	case "Array":
		its := gen.Model.FindType(ts.Items)
		return "[]" + gen.nativeTypeName(&its.TypeSpec, ts.Items)
	case "Map":
		its := gen.Model.FindType(ts.Items)
		kts := gen.Model.FindType(ts.Keys)
		return "map[" + gen.nativeTypeName(&kts.TypeSpec, ts.Keys) + "]" + gen.nativeTypeName(&its.TypeSpec, ts.Items)
	case "Timestamp":
		if gen.runtime {
			gen.addImport("github.com/boynton/sadl")
			return "*sadl." + name
		} else {
			gen.createTimestamp = true
			return "*" + name
		}
	case "UnitValue":
		if gen.runtime {
			gen.addImport("github.com/boynton/sadl")
			return "*sadl." + name
		} else {
			//FIXME
			return "*" + name
		}
	default:
		//must be a app-defined class. Parser should have already verified its existence
		td := gen.Model.FindType(name)
		if td == nil {
			panic("Unresolved type, parser should have caught this: " + name)
		}
		if td.Type == "Struct" {
			name = "*" + name
		}
		return name
	}
}

func capitalize(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}

func uncapitalize(s string) string {
	return strings.ToLower(s[0:1]) + s[1:]
}

func (gen *Generator) EmitTemplate(name string, tmplSource string, data interface{}, funcMap template.FuncMap) {
	if gen.Err != nil {
		fmt.Println("emitTemplate -> already have an error, do not continue:", gen.Err)
		return
	}
	var b bytes.Buffer
	writer := bufio.NewWriter(&b) //first write to a string
	tmpl, err := template.New(name).Funcs(funcMap).Parse(tmplSource)
	if err != nil {
		fmt.Println("emitTemplate -> cannot create template:", gen.Err)
		gen.Err = err
		return
	}
	err = tmpl.Execute(writer, data)
	if err != nil {
		fmt.Println("emitTemplate -> cannot execute template:", gen.Err)
		gen.Err = err
		return
	}
	writer.Flush()
	gen.Emit(b.String())
}
